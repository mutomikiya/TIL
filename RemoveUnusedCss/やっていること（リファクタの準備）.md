- refactor関数を呼び出す
  - つまり以下の関数が呼び出される
  - findAllHtmlFiles()
  - findAllStyleSheetFiles()
  - scanHtmlFilesForUsedElements()
  - scanCssFilesForAllElements()
  - filterCss()
  - prepareForSaving()
- findAllHtmlFiles関数では、htmlFileArray（ex:resource_path(\**/*.blade.php))の各要素を順番にserchPattern変数に代入し、serchPatternに一致するパス名をglob関数で取得してfoundHtmlFiles属性に加える
  - つまり、この時点でremoveUnusedCss -> foundHtmlFiles = ['\**/users.blade.php',・・・,'\**/password.blade.php']のようになる
- findAllStyleSheetFiles関数では、html同様にfoundCssFiles属性に、パターンに一致するstylesheetを配列として加えたあと、もしappendFilename（'.refactored.min）が存在している場合、foundCssFiles配列内の各ファイル（パス名）に対してキー（0スタートの順番）と要素（filename）を順に取り出し、もしfilenameにappendFilenameが含まれている場合は、foundCssFiles配列からそのパス名を削除する
  - すでにrefuctor済のファイルが存在していた場合は取り除くようにする
  - この時点で removeUnusedCss -> foundCssFiles = ['\**/custom.css',・・・,'\**/users.css']のようになる
- scanHtmlFilesForUsedElements関数では、HTMLにマッチするCSSの要素を全て見つける
  - foundHtmlFilesのそれぞれのパス名をfile変数に代入
  - regexForHtmlFiles属性のそれぞれの要素（HTML Tags, CSS Classes, IDs, Data Tags（Without Values), Data Tags(With Values)）をregex変数に代入して、file（パス名）のファイルの内容の文字列に対して正規表現検索を行う
  - まずHtmlTags['regex']では、`<html lang="{{ app()->getLocale() }}">`のような文字列と一致して、これをmatches[0]に、<のあと、空白の前の`html'のような部分をmatches[1]に入れる
  - それから、もしmatches[1]がnullではない場合は、matches[1]のそれぞれの要素（Htmltagsの場合matches[1][0]html、matches[1][1]dev、のようになっている）をmatch変数に代入する
  - さらに、match変数をスペースで区切った文字列の配列のそれぞれの要素をexplodedMatch変数に代入し、それの先頭と末尾に必要な記号をつけたものをformattedMatch変数に代入する
  - formattedMatchには、HTMLタグなら "html"、CSSクラスなら".container"が入っていたりする
  - ここまでの処理をして、もしformattedMatch変数がfoundUsedCssElements属性にまだ含まれていない場合は、foundUsedCssElementsの配列にformattedMatchを加える
- HTMLファイルのパス名の配列foundHtmlFilesを用いて、コード内で用いられているHTMLタグ、CSSクラス、ID、Dataタグを被りの無いように格納したfoundUsedCssElements配列を作ってきた

- 次にscanCssFilesForAllElements関数を呼び出す
  - foundCssFiles（['\**/custom.css',・・・,'\**/users.css']）の要素をそれぞれfile変数に代入する
  - fileの内容を、@mediaの文字列を区切りとして分割した文字列の配列を、breaks変数に代入し、またloop変数を数値（０）として定義する
  - break変数の先頭と末尾のホワイトスペースを取り除く
  - もしloop変数が0であれば、elementForNoMediaBreak属性（文字列__NO_MEDIA__）をkey変数に代入
   - さらにbreakを要素とする配列をcssSectionOfBreakArray変数として定義する  
  - 一方、もしloopが0ではない場合は、@mediaから{まで（ex:@media print{)をkey変数に代入
  - そして、@mediaより後の{から、@media以降の文字列で最後に}が現れる箇所までの文字列をcssSectionOfBreakToArrayize変数に代入
  - そしてこのcssSectionOfBreakToArrayize変数を引数にとってsplitBlockIntoMultiple関数を呼び出してブロック{}ごとに分けた配列をcssSectionOfBreakArray変数に代入する（elseここまで）
  - loop=0の方は、@mediaが登場するまでの全部、elseの方は、ブロック{}ごとの配列
  - cssSectionOfArrayをそれぞれ、キーをcounter、値をcssSectionOfBreak変数に代入
  - もしcounterが0より大きかったら（つまり、@mediaが登場した後の、@mediaじゃないブロック！）elementForNoMediaBreak（文字列__NO_MEDIA__）をkeyに代入する（ifここまで）
  - regexForCssFilesの各要素をregex変数に代入し、cssSectionOfBreak変数を正規表現で検索し、一致するものをmatchesに代入していく
  - 正規表現では`ul{padding:0;}`のような表現がマッチし、１番目のサブパターンマッチ（matches[1]）には`ul`のようなセレクタ、matches[2]には`padding:10;`のようなプロパティと値が格納される
  - もしmatches変数が空ではない場合は、matches[1]の各要素を、keyをregexKey、値をelementに代入する
  - そして、foundCssStructure配列の[file（パス名）][key（__NO_MEDIA__)][element内の空白文字の連続をスペースに置き換えたもの]に、matches[2][regexKey]から空白文字の連続をスペースに置き換えたものを代入する
  - （ex: `foundCssStructure[common.css][__No_MEDIA__][ul]=[{padding:10; margin:0; list-style:none;}]`）
  - そして、loopに１を加える
  - ここでやってきたのは、cssファイルのパス名の配列foundCssFilesを元にその内容を取得し、@mediaの有無で処理を分ける
  - ない場合は、cssSectionOfBreakArrayに、ファイルの中身が丸ごと１つの要素として入っていて、keyがNO_MEDIAのような状態になっている
  - ある場合は、@media以降の部分がcssSectionOfBreakArrayに{}ブロックごとの配列として格納されていて、@media対象のブロックのkeyは@media{}のような形に、それ以外のブロックのkeyはNO_MEDIAになる
  - foundCssStructureに、同じ階層にある全てのcssファイルについて、ファイル名前、@mediaの有無、セレクタをキーにしたcssのプロパティと値が格納されている状態になっている

 
